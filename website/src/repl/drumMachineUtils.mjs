// Drum Machine Utils - Audio Engine for Strudel Integration
// Uses tidal-drum-machines samples from dough-samples

const SAMPLES_JSON_URL = 'https://raw.githubusercontent.com/felixroos/dough-samples/main/tidal-drum-machines.json';

// Instrument mapping: internal ID -> Strudel ID
export const instruments = [
  { id: 'kick', label: 'KICK', icon: 'ðŸ¥', strudelId: 'bd' },
  { id: 'snare', label: 'SNARE', icon: 'ðŸŽ¯', strudelId: 'sd' },
  { id: 'hihat', label: 'HI-HAT', icon: 'ðŸŽ©', strudelId: 'hh' },
  { id: 'openhat', label: 'OPEN', icon: 'ðŸ”“', strudelId: 'oh' },
  { id: 'clap', label: 'CLAP', icon: 'ðŸ‘', strudelId: 'cp' },
  { id: 'crash', label: 'CRASH', icon: 'ðŸ’¥', strudelId: 'cr' },
  { id: 'rim', label: 'RIM', icon: 'ðŸ¥¢', strudelId: 'rim' },
  { id: 'cowbell', label: 'BELL', icon: 'ðŸ””', strudelId: 'cb' },
];

// Cache for samples JSON
let samplesCache = null;

/**
 * Fetch and cache the tidal-drum-machines.json
 */
export async function fetchSamplesData() {
  if (samplesCache) return samplesCache;

  try {
    const response = await fetch(SAMPLES_JSON_URL);
    samplesCache = await response.json();
    return samplesCache;
  } catch (error) {
    console.error('Failed to fetch drum samples:', error);
    return {};
  }
}

/**
 * Get list of available drum machine kits
 */
export async function getAvailableKits() {
  const data = await fetchSamplesData();
  const kits = new Set();

  for (const key of Object.keys(data)) {
    if (key.includes('_bd')) {
      const kitName = key.split('_')[0];
      kits.add(kitName);
    }
  }

  return Array.from(kits).sort().map(name => ({
    name,
    displayName: formatKitName(name),
  }));
}

/**
 * Format kit name for display (e.g., "RolandTR808" -> "Roland TR-808")
 */
function formatKitName(name) {
  return name
    .replace(/([a-z])([A-Z])/g, '$1 $2')
    .replace(/TR(\d+)/g, 'TR-$1')
    .replace(/CR(\d+)/g, 'CR-$1')
    .replace(/DR(\d+)/g, 'DR-$1')
    .replace(/KR(\d+)/g, 'KR-$1');
}

/**
 * Load a single audio sample
 */
async function loadSample(url, audioContext) {
  try {
    const response = await fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    return await audioContext.decodeAudioData(arrayBuffer);
  } catch (error) {
    console.warn(`Failed to load sample: ${url}`, error);
    return null;
  }
}

/**
 * Load all samples for a drum kit
 */
export async function loadDrumKit(kitName, audioContext) {
  const data = await fetchSamplesData();
  const buffers = {};

  const loadPromises = instruments.map(async (inst) => {
    const key = `${kitName}_${inst.strudelId}`;
    const sampleData = data[key];

    if (sampleData) {
      // Handle both single URLs and arrays of URLs
      const url = Array.isArray(sampleData) ? sampleData[0] : sampleData;
      buffers[inst.id] = await loadSample(url, audioContext);
    }
  });

  await Promise.all(loadPromises);
  return buffers;
}

/**
 * Play a sound from the loaded buffers
 */
export function playSound(instId, buffers, audioContext, options = {}) {
  const buffer = buffers[instId];
  if (!buffer || !audioContext) return;

  const { gain = 0.8, pitch = 0 } = options;

  const source = audioContext.createBufferSource();
  source.buffer = buffer;

  // Apply pitch shift
  if (pitch !== 0) {
    source.playbackRate.value = Math.pow(2, pitch / 12);
  }

  const gainNode = audioContext.createGain();
  gainNode.gain.value = gain;

  source.connect(gainNode);
  gainNode.connect(audioContext.destination);

  source.start(0);

  return source;
}

/**
 * Convert a pattern array to mini-notation string
 * [1,0,0,1,0,0,1,0] -> "x ~ ~ x ~ ~ x ~"
 */
export function stepsToMiniNotation(steps, instrument) {
  const notation = steps.map(s => s ? instrument : '~').join(' ');

  // Optimize: replace repeated instruments with multiplication
  // e.g., "hh hh hh hh hh hh hh hh" -> "hh*8"
  const parts = notation.split(' ');
  const allSame = parts.every(p => p === parts[0]);
  const activeCount = parts.filter(p => p !== '~').length;

  if (allSame && parts[0] !== '~') {
    return `${parts[0]}*${parts.length}`;
  }

  // Check for simple patterns that can use Euclidean notation
  if (activeCount > 0 && activeCount <= 5) {
    const positions = parts.map((p, i) => p !== '~' ? i : -1).filter(i => i >= 0);
    // Could add Euclidean detection here
  }

  return notation;
}

/**
 * Convert full pattern state to Strudel code
 */
export function patternToStrudel(pattern, kitName, bpm) {
  const lines = [];
  lines.push(`// Generated by Casa 24 Drum Machine`);
  lines.push(`setcps(${bpm}/60)  // ${bpm} BPM`);
  lines.push('');
  lines.push('stack(');

  const activePatterns = [];

  for (const inst of instruments) {
    const steps = pattern[inst.id];
    if (!steps || steps.every(s => !s)) continue;

    const notation = stepsToMiniNotation(steps, inst.strudelId);
    activePatterns.push(`  s("${notation}").bank("${kitName}")`);
  }

  if (activePatterns.length === 0) {
    lines.push('  // No patterns yet - click some steps!');
    lines.push('  s("bd sd").bank("RolandTR808")');
  } else {
    lines.push(activePatterns.join(',\n'));
  }

  lines.push(')');

  return lines.join('\n');
}

/**
 * Create initial empty pattern state
 */
export function createEmptyPattern(steps = 16) {
  const pattern = {};
  for (const inst of instruments) {
    pattern[inst.id] = new Array(steps).fill(false);
  }
  return pattern;
}

/**
 * Preset patterns for quick start
 */
export const presetPatterns = {
  trap: {
    name: 'Trap',
    bpm: 140,
    pattern: {
      kick: [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],
      snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      hihat: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      openhat: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      clap: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      crash: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      rim: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      cowbell: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    },
  },
  house: {
    name: 'House',
    bpm: 125,
    pattern: {
      kick: [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
      snare: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      hihat: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
      openhat: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      clap: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      crash: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      rim: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      cowbell: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    },
  },
  dembow: {
    name: 'Dembow',
    bpm: 95,
    pattern: {
      kick: [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
      snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      hihat: [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
      openhat: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      clap: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      crash: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      rim: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      cowbell: [0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0],
    },
  },
  drill: {
    name: 'UK Drill',
    bpm: 142,
    pattern: {
      kick: [1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0],
      snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      hihat: [1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,0],
      openhat: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      clap: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      crash: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      rim: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      cowbell: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    },
  },
};
